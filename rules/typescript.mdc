# TypeScript Rules

### Priority Levels

- ðŸ”´ **Hard rule** â€” must always be followed. No exceptions without explicit approval.
- ðŸŸ¡ **Strong preference** â€” default behavior; deviate only with a clear reason.
- âšª **Guideline** â€” situational; use judgment.

### Type System

- ðŸŸ¡ Avoid explicit type annotations unless they materially improve readability. Prefer inference.
- ðŸ”´ Never use `any` unless explicitly approved and we are deliberately pushing TypeScript's limits. This should be extremely rare.
- ðŸŸ¡ If the type is genuinely unknown, prefer `unknown`.
- ðŸŸ¡ Avoid type casting. Only cast when strictly necessary to make something work, not as a convenience.
- ðŸ”´ Never manually redefine types that can be derived or imported. If a type exists elsewhere in the app or a library, import it.
- ðŸŸ¡ For values from untrusted or unknown sources, use Zod to validate at runtime and infer types (e.g. `JSON.parse`).
- ðŸ”´ Do not create `.d.ts` files for declaring modules.
- ðŸŸ¡ Design types to be as specific as possible as early (high) in the type graph as possible.
- ðŸ”´ Never use `as unknown as`. It is always wrong.
- ðŸ”´ Never use `@ts-expect-error`, `@ts-ignore`, or similar.
- âšª One acceptable use-case of `any` is when you're using `infer` keyword or declaring generic functions, and you need to skip a generic parameter we don't care about. e.g. `type SomeType<T> = T extends ManyArgGeneric<any, any, infer U> ? U : never`. This is preferred over passing the specific types those arguments extend since this definition is unrelated to those specific types; thus, our `SomeType` definition won't break if args 1 and 2 of `ManyArgGeneric` change.
