# General Coding Rules

### Priority Levels

- ðŸ”´ **Hard rule** â€” must always be followed. No exceptions without explicit approval.
- ðŸŸ¡ **Strong preference** â€” default behavior; deviate only with a clear reason.
- âšª **Guideline** â€” situational; use judgment.

### Setup/Runtime
- ðŸ”´ Only ever use Bun as the package manager and runtime. This includes running scripts e.g. `bunx shadcn@latest add menu`

### Research
- ðŸŸ¡ When using a library, always research the latest docs. I know you may be familiar with the library, but your knowledge is often out of date. 

### Functions

- ðŸŸ¡ Use `function` declarations for top-level and exported functions. Use arrow functions for inline callbacks and closures.

### Variables & Control Flow

- ðŸŸ¡ Prefer `const` unless mutation is intentional and required.
- âšª Inline values used once unless it harms readability.
- ðŸŸ¡ Do not hoist magic values into constants unless they are reused or semantically meaningful.
- ðŸŸ¡ Avoid deep nesting. Extract small, pure helpers when helpful.
- ðŸŸ¡ Be wary of variables that exist only due to iterative edits. Re-evaluate which variables actually need to exist and simplify aggressively.

### Declarative Style

- ðŸŸ¡ Prefer declarative, expression-based code over imperative mutation. Build objects and arrays in a single expression rather than declaring an empty/partial value and conditionally mutating it.
  - This is critical for type inference. Declarative construction lets TypeScript infer the full shape automatically, whereas imperative mutation (declare-then-assign) forces vague annotations like `Record<string, unknown>` that destroy downstream type safety.
  - Use conditional spreads (`...(condition && { key: value })`) and ternaries for conditional properties.
  - Use `Array.filter`, `.map`, `.flatMap`, etc. over imperative loops with `push`.
- ðŸŸ¡ When vanilla JS lacks the right utility, reach for Remeda (`R`). It provides well-typed functional utilities (`pipe`, `filter`, `map`, `groupBy`, `merge`, `pickBy`, etc.) that keep code declarative without sacrificing type safety. Remeda is available in nearly all of my projects.
- ðŸŸ¡ Prefer Remeda's `pipe` over chained native array methods (`.map().filter()`, etc.). Remeda fuses piped operations into a single loop via lazy evaluation, avoiding intermediate array allocations.

### Concurrency

- ðŸŸ¡ Use `Promise.all` when possible to speed things up.

### Imports & Exports

- ðŸ”´ Always remove unused imports.
- ðŸ”´ Never separate an `export` statement from its declaration.

### Error Handling

- ðŸŸ¡ Use `try/catch` very sparingly.
- ðŸŸ¡ Only use it when meaningful work needs to happen in response to an error.
- ðŸ”´ Do not use `try/catch` just to swallow errors or re-log them.

### Linting & Formatting

- ðŸ”´ Every project must have these four package scripts:
	- `lint` â€” run the linter
	- `format` â€” run the formatter
	- `fix` â€” lint with auto-fix + format
	- `check` â€” type-check + fix (`tsc --noEmit && bun run fix`)
- ðŸ”´ After edits, always run `bun run check` until the output is clean.
- ðŸ”´ Never silence lints with directive comments. If you think this is necessary, stop and ask first.
- ðŸ”´ Never fix lints manually that the linter can auto-fix.

### Documentation & Comments

- ðŸŸ¡ Comment only when intent is not obvious from code.
- ðŸŸ¡ Prefer self-explanatory code through naming and structure.
- ðŸ”´ Never comment obvious behavior (e.g. "increment counter").
- ðŸ”´ If you break any of the coding rules, leave a comment with `REVIEW: [reason]`.
- ðŸŸ¡ Document every function declaration unless painfully simple/obvious. However, don't use JSDoc tags. Only use simple descriptions. You don't even really need to include examples unless they're small and/or help a lot. Most importantly, just document any quirks developers may need to know about when using it. Still use JSDoc comment block syntax though e.g. `/** */`
- ðŸŸ¡ For comments, if you're simply describing what a line does, use `//`. If you're documenting a variable or function, use JSDoc comment blocks `/** */`

### Git

- ðŸ”´ Never perform Git writes unless explicitly instructed.
- ðŸŸ¡ If asked to commit, keep commit messages short (ideally ~10 words, never more than ~50).

### Dependencies

- ðŸ”´ Always add dependencies using `bun add`.
- ðŸ”´ Do not manually edit `package.json` to add versions first; let Bun resolve the version automatically.
- ðŸ”´ After adding a **workspace dependency**, always run `bun install` so the workspace links correctly.

### Tooling & Scaffolding

- ðŸŸ¡ Prefer using official CLI tools or generators over manually creating or editing files when possible.
- âšª This applies especially to setup, scaffolding, and config files, where CLIs encode best practices.

### Object & Value Handling

- ðŸŸ¡ Avoid unnecessary spreads (e.g. `{ ...obj }`).
  - Confirm the spread is actually needed to create a new reference.
- ðŸŸ¡ Avoid manually re-listing all object properties (e.g. `{ x: a.x, y: a.y, z: a.z }`).
  - Prefer object spread, or `R.pick` / `R.omit` when using Remeda.
- ðŸŸ¡ Avoid unnecessary defaults, coalescing, optional chaining, or conditions.
  - Example: `x ?? 0` when `x: number`.

### Conditionals

- ðŸŸ¡ Use the simplest check that is correct.
- ðŸŸ¡ Prefer truthy/falsy checks when appropriate.
  - Example: `if (obj)` instead of `if (obj != null)` when `obj: Record<string, unknown> | null`.
- ðŸŸ¡ Avoid strict `===` / `!==` for nullish checks unless the distinction between `null` and `undefined` matters.
  - Example: `if (str != null)` instead of `if (str !== undefined)` when `str: string | undefined`.
